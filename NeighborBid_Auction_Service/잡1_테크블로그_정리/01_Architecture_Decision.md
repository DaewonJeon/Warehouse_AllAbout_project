# 0.1초의 승부: 경매 시스템의 안정성과 실시간성을 모두 잡는 법

안녕하세요, NeighborBid 팀 서버 개발자입니다.

오늘은 우리 팀이 실시간 경매 서비스를 만들며 마주했던 가장 큰 기술적 난제, **'돈이 오가는 결제의 안정성'**과 **'0.1초를 다투는 경매의 실시간성'**이라는 두 마리 토끼를 어떻게 잡았는지 공유해 드리려 해요.

## 경매 서비스의 딜레마

NeighborBid는 기본적으로 두 가지의 상반된 성격을 가진 기능이 공존해야 했어요.

1.  **Track A (결제, 로그인):** "기록의 정확성"이 생명입니다. 단 1원의 오차나 데이터 유실도 허용해서는 안 되죠.
2.  **Track B (실시간 호가):** "속도와 동시성"이 핵심입니다. 내가 입찰 버튼을 누르자마자 모든 사용자에게 반영되어야 하니까요.

처음에는 하나의 통신 방식으로 이 모든 것을 처리하려다 보니 문제가 생겼습니다. HTTP로만 처리하자니 실시간 경쟁에서 딜레이가 발생했고, WebSocket으로 모든 것을 처리하자니 단순 조회나 결제 기능에서 불필요하게 서버 리소스를 점유하는 비효율이 발생했죠.

## 해결책 1: 프로토콜의 이원화 (HTTP & WebSocket)

그래서 우리는 **기능의 목적에 따라 통신 방식을 과감하게 분리**하기로 결정했습니다.

### "돈은 HTTP로, 경쟁은 WebSocket으로"

*   **HTTP (Stateless) for Stability:**
    *   결제나 회원가입 처리에 사용해요. 연결 유지 비용이 없고, 표준화된 요청/응답 구조 덕분에 트랜잭션의 안정성을 보장하기 유리하죠.
*   **WebSocket (Stateful) for Speed:**
    *   실시간 호가 업데이트에 사용해요. 헤더 오버헤드 없이 데이터를 즉시 Push 할 수 있어, 사용자에게 '단톡방'처럼 매끄러운 입찰 경험을 제공할 수 있었어요.

이 전략은 서버의 부하를 효율적으로 분산시키고, 사용자에게는 끊김 없는 경험을 제공하는 최적의 타협점이 되었습니다.

---

## 해결책 2: 서버 레이어의 분리 (WSGI & ASGI)

프로토콜을 나누었다면, 이를 받아주는 서버 구조도 그에 맞춰야겠죠? 우리는 **Reverse Proxy(Nginx)** 뒤단에 두 개의 애플리케이션 서버를 배치했습니다.

### Nginx: 똑똑한 교통 정리

Nginx가 게이트웨이 역할을 맡아 트래픽을 분류합니다. `/ws/`로 시작하는 웹소켓 요청은 ASGI 서버로, 그 외의 일반 요청은 WSGI 서버로 라우팅을 수행해요. 덕분에 백엔드 서버는 각자 잘하는 일에만 집중할 수 있게 되었죠.

| 서버 종류 | 역할 | 선택 이유 |
| :--- | :--- | :--- |
| **WSGI (Gunicorn)** | HTTP 요청 처리 (Django) | **안정성(Stability).** Pre-fork 모델로 멀티 프로세스를 지원해, 하나의 워커가 죽어도 서비스 전체가 멈추지 않아요. 결제 트랜잭션에 필수적이죠. |
| **ASGI (Daphne/Uvicorn)** | WebSocket 요청 처리 | **비동기(Async).** 수만 명의 동시 연결을 유지하며 실시간 입찰 정보를 밀어주기(Push) 위해선 비동기 처리가 필수적이에요. |

결국 **'안정성 vs 실시간성'의 딜레마를 서버 이원화 전략으로 해결**한 셈입니다.

---

## 해결책 3: 데이터 저장소의 적재적소 (Redis & PostgreSQL)

마지막으로, 데이터 저장소 역시 속도와 안정성 사이에서 균형을 맞춰야 했습니다.

### Redis: 0.1초의 속도를 위하여
Disk 기반의 RDBMS는 쇄도하는 입찰 요청을 실시간으로 감당하기엔 병목(Bottleneck)이 발생할 수밖에 없었어요.
그래서 우리는 **In-Memory DB인 Redis**를 도입했습니다. RAM에서 동작하는 Redis는 수백 배 빠른 읽기/쓰기 속도를 보장하고, 특히 **Pub/Sub 기능**을 통해 실시간 메시지를 중계하는 역할을 톡톡히 해냈습니다.

### Celery: 사용자를 기다리게 하지 않기
입찰이 완료된 후 DB에 저장하거나 이메일을 보내는 무거운 작업은 어떻게 할까요? 사용자가 로딩 화면을 보게 할 순 없죠.
우리는 "입찰 접수됨"을 즉시 응답하고, 무거운 뒷정리는 **Celery**에게 맡겨 백그라운드에서 비동기로 처리하도록 했습니다.

### PostgreSQL: 결국 남는 것은 데이터
하지만 Redis는 휘발성 메모리입니다. 최종적인 거래 내역과 낙찰 데이터는 가장 신뢰할 수 있는 관계형 데이터베이스인 **PostgreSQL**에 안전하게 보관하여 데이터 무결성(ACID)을 지켰습니다.

---

## 마치며

NeighborBid의 아키텍처는 기술적 화려함보다는 **'적재적소(Right Tool for the Right Job)'** 라는 원칙에 충실했습니다.

*   빠른 처리는 **Redis와 ASGI**가,
*   안전한 저장은 **PostgreSQL과 WSGI**가,
*   무거운 작업은 **Celery**가 나누어 맡도록 했죠.

앞으로도 우리는 대규모 트래픽 앞에서도 흔들리지 않는, 빠르면서도 안전한 경매 시스템을 만들어갈 예정입니다. 읽어주셔서 감사합니다.
